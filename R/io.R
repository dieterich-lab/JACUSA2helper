#' Read JACUSA result file
#'
#' \code{read_result()} Reads data that was generated by JACUSA2 and create a special data.frame.
#'
#' @param file String represents the filename of the JACUSA2 output.
#' @param showProgress Boolean indicates if a progress should be monitored.
#'
#' @export
read_result <- function(file, showProgress = TRUE, method = "auto") {
  # pre process file
  # parse comments ^(#|##) to determine result/method type and number of conditions
  con <- file(file, "r")
  conditions <- 0
  condition_container <- NULL
  header_names <- NULL
  skip_lines <- 0
  # possible result/method types: unknown, call-pileup, rt-arrest, lrt-arrest
  type <- .METHOD_TYPE_UNKNOWN
  while (TRUE) {
    line = readLines(con, n = 1)
    # quit reading: nothing to read or first no header line 
    if (length(line) == 0 || length(grep("^#", line)) == 0) {
      break
    }
    # count header lines to ignore
    skip_lines <- skip_lines + 1

    # try to guess result/method by header line
    if (type == .METHOD_TYPE_UNKNOWN && length(grep("^#contig", line)) > 0) {
      type <- .guess_file_type(line)
      
      # parse and store header
      # fix header: #contig -> contig
      header_names <- sub("^#", "", line);
      header_names <- unlist(strsplit(header_names, "\t"))
    }
  
    # guess number of conditions  
    if (conditions == 0 && length(grep("^#contig", line)) > 0) {
      condition_container <- .guess_conditions(line)
      conditions <- length(unique(condition_container$conditions))
    }
  }
  # finished pre-processing
  close(con)
  
  # check that the type could be guessed
  if (type == .METHOD_TYPE_UNKNOWN) {
    stop("Result type could not be guessed for file: ", file)
  }
  
  # check that a header could be parsed
  if (is.null(header_names)) {
    stop("No header line for file: ", file)
  }
  
  # check that conditions could be guessed
  if (conditions < 1) {
    stop("Conditions cannot be < 0")
  }
  
  # read data
  data <- data.table::fread(file, skip = skip_lines, sep = "\t", header = FALSE, showProgress = showProgress)  
  colnames(data) <- header_names

  # create container depending on determined result/method type 
  container <- .create_container(type, data, conditions)
  
  # create combined position id from genomic coordinates
  container$id <- .create_id(container)

  container <- c(container, condition_container)
  
  container
}

# Create combined position id from genomic coordinates
.create_id <- function(containter) {
  paste(container$contig, container$start, container$end, container$strand, sep = ":")
}

# Create container for type and conditions from data 
.create_containter <- function(type, data, conditions) {
  containter <- NULL
  if(type == .METHOD_TYPE_CALL_PILEUP) {
    containter <- .create_call_pileup(data, conditions)
  } else if (type == .METHOD_TYPE_RT_ARREST) {
    containter <- .create_rt_arrest(data, conditions)
  } else if (type == .METHOD_TYPE_LRT_ARREST) {
    containter <- .create_lrt_arrest(data, conditions)
  } else {
    stop("Unknown type: ", type)
  }
  containter$type <- type
  
  # extract data from info field
  containter <- separate_rows(containter, info, sep = ";")                                                                                                                                                      
  containter <- separate(containter, col = info, into = c("key", "value"), sep = "=")                                                                                                                           
  containter <- spread(containter, key, value, convert = TRUE)
  
  containter
}

# Guess number of conditions from header line
.guess_conditions() <- function(line, type = .guess_file_type(line)) {
  # header line: "#contig\t[...]" is required
  if (length(grep("^#contig", line)) == 0) {
    stop("Invalid header line: ", line)
  }

  if (type == .METHOD_TYPE_UNKNOWN) {
    stop("Unknown type: ", type)
  }
  
  conditions <- -1
  if (type == .METHOD_TYPE_CALL_PILEUP) {
    conditions <- .guess_conditions_call_pileup(line)
  } else if (type == .METHOD_TYPE_LRT_ARREST) {
    conditions <- .guess_conditions_lrt_arrest(line)
  } else if (type == .METHOD_TYPE_RT_ARREST) {
    conditions <- .guess_conditions_rt_arrest(line)
  } else {
    stop("Unknown type: ", type)
  }
  
  conditions
}

# Guess paritioning of conditions and replicates from labels
.guess_conditions <- function(labels) {
  conditions <- 1
  max_conditions <- length(labels)
  
  split_labels <- function(labels, conditions) {
    conditions_length <- nchar(conditions)
    condition <- substring(labels, first = conditions_length, last = conditions_length)
    replicate <- substring(labels, first = conditions_length + 1)
    if (nchar(condition) == 0 || nchar(replicate) == 0) {
      return(NA)
    }
    if (length(unique(condition)) != conditions) {
      return(NA)
    }
    
    list(condition = as.numeric(condition), replicate = as.numeric(replicate))
  }
  
  while (conditions <= max_conditions) {
    guess <- split_labels(labels, conditions)
    if (length(guess) == 2) {
      return(guess)
    }
    conditions <- conditions + 1
  }
  
  stop("Conditions could not be guessed from: ", labels)
}

# Extract condition-replicate part from line
.extract_labels <- function(line, prefix) {
  prefix <- paste0("^", prefix)
  i <- grep(prefix, line)
  labels <- line[i]
  labels <- gsub(prefix, "", labels)
  
  labels
}

# Guess conditions for JACUSA2.x methods
.guess_conditions_call_pileup <- function(line) {
  labels <- .extract_labels(line, "bases")
  
  .guess_conditions(labels)
}
.guess_conditions_rt_arrest <- function(line) {
  labels <- .extract_labels(line, "arrest")
  
  .guess_conditions(labels)
}
.guess_conditions_lrt_arrest <- function(line) {
  labels <- .extract_labels(line, "arrest")
  
  .guess_conditions(labels)
}

# Determine file type base on header line
.guess_file_type() <- function(line) {
  # header line: "#contig\t[...]" is required
  if (length(grep("^#contig", line)) == 0) {
    stop("Invalid header line: ", line)
  }
  
  type <- .METHOD_TYPE_UNKNOWN
  if (length(grep("arrest_pos", line)) > 0) { # lrt-arrest
    type <- .METHOD_TYPE_LRT_ARREST
  } else if(length(grep("\tarrest_bases", line)) > 0) { # rt-arrest
    type <- .METHOD_TYPE_RT_ARREST
  } else if (length(grep("\tbases", line)) > 0) { # call-pileup
    type <- .METHOD_TYPE_CALL_PILEUP
  } else { # ERROR: type could not be guessed
    stop("Result type could not be guessed from header: ", line)
  }
  
  type
}

#' Write vector of values as bedGraph file
#'
#' \code{write_bedGraph()} Writes a bedGraph conform file with coordinates
#' defined by vectors: "contig", "start", and "end". According to:
#' https://genome.ucsc.edu/goldenPath/help/bedgraph.html
#' "start" and "end" are zero index and half opened. The caller needs to make sure 
#' that this is fullfilled.
#'
#' @param file String represents the filename of the BED graph file.
#' @param contig Vector of character vectors
#' @param start Vector of numericals zero indexed (>= 0)
#' @param end Vector of numericals half opened: [start, end)
#' @param value Vector of characters or numericals the reference value(s)
#'
#' @export
write_bedGraph <- function(file, contig, start, end, value) {
  # make sure start >= 0 - adhere to bedGraph file format
  if (any(start < 0)) {
    stop("Invalid data: some start > end")
  }
  # data frame to be written to file
  d <- data.frame(
    contig = contig, 
    start = start, end = end, 
    value = value, 
    stringsAsFactors = FALSE)
  write.table(d, file, quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
}

.create_bases <- function(dt, conditions, default_bases = "all") {
  # convert wide to long
  r <- tidyr::gather(dt, sample, bases, dplyr::contains("bases"))
  i <- startsWith(r$sample, "bases")
  if (length(i) > 0) {
    r$sample[i] <- paste0(default_bases, "_", r$sample[i])
  }
  # extract condition and replicate
  r <- tidyr::extract(r, sample, c("base_type", "condition", "replicate"), 
                      regex = paste0("^(.+)_bases([0-9]{", nchar(conditions), "})([0-9]+)"), 
                      remove = TRUE, convert = TRUE)
  # extract base call columns from "," encoded strings
  # convert string: "0,10,2,0" to new columns: bc_A = 0, bc_C = 10, bc_G = 2, bc_T = 0
  r <- tidyr::separate(r, bases, paste0("bc_", c("A", "C", "G", "T")), 
                       sep = ",", remove = TRUE, convert = TRUE)

  if (length(unique(r$base_type)) == 1) {
    r$base_type <- NULL
  }
  
  r
}

# helper functions to create data container to hold data
.create_call_pileup <- function(dt, conditions) {
  r <- .create_base(dt, conditions)
  
  r
}
# FIXME
.create_rt_arrest <- function(dt, conditions) {
  r <- .create_bases(dt, conditions)

  r
}
# FIXME
.create_lrt_arrest <- function(dt, conditions) {
  # convert wide to long (samples start with "reads(condition)(replicate)")
  tmp_r <- tidyr::gather(dt[, grep("^reads", colnames(dt))], sample, reads, dplyr::starts_with("reads"))
  # not needed; condition and replicate already set
  # extract read arrest and read through columns from "," encoded strings
  # convert string: "0,10" to new columns: read_arrest = 0, read_through = 10
  tmp_r <- tidyr::separate(tmp_r, reads, paste0("read_", c("arrest", "through")), 
                       sep = ",", remove = TRUE, convert = TRUE)
  
  # convert wide to long (samples start with "ref2bc(condition)(replicate)")
  r <- tidyr::gather(dt[, grep("^reads", colnames(dt), invert = TRUE)], sample, ref2bc, dplyr::starts_with("ref2bc"))
  # extract condition and replicate
  r <- tidyr::extract(r, sample, c("condition", "replicate"), 
               regex = paste0("^ref2bc([0-9]{", nchar(conditions), "})([0-9]+)"), 
               remove = TRUE, convert = TRUE)

  # append tmp_r order of condition and replicates is the same in r and tmp_r
  r$read_arrest <- tmp_r$read_arrest
  r$read_through <- tmp_r$read_through
  
  # base substitutions per read arrest position
  # expected format: 
  # "*" if no base sub.
  # on base sub.: 100:10,0,0,0 -> at ref. pos. 100 there are 10 A(denosines)
  # base sub. separated by ";"
  base_sub <- strsplit(r$ref2bc, ";")
  base_sub_count <- unlist(lapply(base_sub, length))
  base_sub <- unlist(base_sub)
  i <- base_sub == "*"
  base_sub[i] <- "-1:0,0,0,0"
  # create container to fit base substitutions
  r <- r[rep(seq(1, nrow(r)), base_sub_count), ]
  # store base substitutions in container
  r$ref2bc <- base_sub
  # split 100:10,0,0,0 -> bc_position = 100, bc_A = 10, bc_C = 0, bc_G = 0, bc_T = 0
  r <- tidyr::extract(r, ref2bc,
                into = c("bc_position", paste0("bc_", c("A", "C", "G", "T"))), 
                regex = paste0("([0-9-]+):([0-9]+),([0-9]+),([0-9]+),([0-9]+)"), 
                remove = TRUE, convert = TRUE)
  i <- r$bc_position == -1
  r$bc_position[i] <- NA

  # parse filtering
  # separate multiple filters into rows
  f <- separate_rows(r[, c("bc_position", "filter_info")], filter_info, sep = ";", convert = T)
  f <- tidyr::extract(f, filter_info,
                      into = c("filter", "filter_position"), 
                      regex = paste0("([[:alnum:]]+)=([0-9,]+)"), 
                      remove = TRUE, convert = TRUE)
  f <- tidyr::separate_rows(f, filter_position, sep = ",", convert = T)
  # set NA to "*"
  i <- is.na(f$filter)
  f$filter[i] <- "*"
  f$filter_position[i] <- "*"
  i <- is.na(f$filter_position)
  f$filter_position[i] <- "*"
  # remove sites where bc_position does not match filter_position
  i <- f$filter_position == "*" | f$filter_position != "*" & f$bc_position == f$filter_position
  # TODO merge sites
  r <- f[i, "filter"]
  
  r
}

#' Write a JACUSA list object to a file
#'
#' \code{write_result} Stores a list of sites in a file.
#' 
#' @param jacusa List created by \code{read_jacusa()}.
#' @param file String is the filename to store the list.
#' @param extra Vector of strings that define additional elements from the list that 
#'        will be stored in the file. 
#'
#' @export 
write_result <- function(jacusa, file, extra = NULL) {
  bed6 <- names(jacusa)[names(jacusa) %in% c("contig", "start", "end", "name", "stat", "pvalue", "strand")]
  
  data_fields <- c()
  data_type <- 0

  # add bases fields
  i <- grep("^bases", names(jacusa))
  base_fields <- names(jacusa)[i]
  if (length(base_fields > 0)) {
    data_fields <- c(data_fields, base_fields)
    data_type <- data_type + 1
  }
  
  # add ref2bc fields
  i <- grep("^ref2bc", names(jacusa))
  ref2bc_fields <- names(jacusa)[i]
  if (length(ref2bc_fields > 0)) {
    data_fields <- c(data_fields, ref2bc_fields)
    data_type <- data_type + 1
  }
  
  # add read arrest through fields
  i <- grep("arrest_bases|through_bases", names(jacusa))
  reads_fields <- names(jacusa)[i]
  if (length(reads_fields > 0)) {
    data_fields <- c(data_fields, reads_fields)
    data_type <- data_type + 1
  }

  # rearrange data fields
  if (data_type == 2) {
    tmp <- vector("character", length(data_fields))
    n <- length(data_fields)
    h <-  n / 2
    tmp[seq(1, n, 2)] <- data_fields[1:h]
    tmp[seq(2, n, 2)] <- data_fields[(h+1):n]
    data_fields <- tmp
  }
  
  info <- names(jacusa)[names(jacusa) %in% c("info", "filter_info", "refBase")]
  
  fields <- c(bed6, data_fields, info)
  if (! is.null(extra)) {
    fields <- c(fields, extra)
  }

  jacusa <- jacusa[fields]

  d <- as.data.frame(jacusa, stringsAsFactors = FALSE, check.names = FALSE)
  colnames(d)[1] <- paste0("#", colnames(d)[1])
  utils::write.table(d, file, col.names = TRUE, row.names = FALSE, quote = FALSE, sep = "\t")
}

# TODO JACUSA2.x specific write methods
.write_call_result <- function(jacusa, file, extra = NULL) {
  # TODO
}

.write_pileup_result <- function(jacusa, file, extra = NULL) {
  # TODO
}

.write_lrt_arrest_result <- function(jacusa, file, extra = NULL) {
  # TODO
}

.write_rt_arrest_result <- function(jacusa, file, extra = NULL) {
  # TODO
}
