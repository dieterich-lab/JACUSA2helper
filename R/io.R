#' TODO Read JACUSA result file
#'
#' \code{read_jacusa()} Reads data that was generated by JACUSA2.
#'
#' @param file String represents the filename of the JACUSA output.
#' @param ... Additional parameters that will be forwarded to read.table.
#'
#' @export
read_jacusa <- function(file, ...) {
	d <- utils::read.table(file, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE, comment.char = "", ...) 
	colnames(d)[1] <- gsub("^#", "", colnames(d)[1])
	jacusa <- as.list(d)
	jacusa
}

#' Read JACUSA result file
#'
#' \code{read_result()} Reads data that was generated by JACUSA2.
#'
#' @param file String represents the filename of the JACUSA2 output.
#'
#' @export
read_result <- function(file, showProgress = TRUE) {
  # TODO
  # fallback when conditions cannot be guessed from header

  # pre process file
  # parse comments ^(#|##) to determine result/method type and number of conditions
  con = file(file, "r")
  conditions <- 0
  skip_lines <- 0
  # possible result/method types: unknown, call-pileup, rt-arrest, lrt-arrrest
  type <- "unknown"
  while (TRUE) {
    line = readLines(con, n = 1)
    if (length(line) == 0 || length(grep("^#", line)) == 0) {
      break
    }
    # count lines to ignore
    if (length(grep("^##", line)) > 0) {
      skip_lines <- skip_lines + 1
    }
    # count condition header lines
    if (length(grep("^## condition", line)) > 0) {
      conditions <- conditions + 1
    }
    # try to guess result/method by header line
    if (type == "unknown" && length(grep("^#contig", line)) > 0) {
      if (length(grep("ref2bc", line)) > 0) { # lrt-arrest
        type <- "lrt-arrest"
      } else if(length(grep("reads", line)) > 0) { # rt-arrest
        type <- "rt-arrest"
      } else if (length(grep("reads", line)) > 0) { # call-pileup
        type <- "call-pileup"
      } else { # cannot be guessed
        stop("Result type cannot be guessed from header:\n", line)
      }
    }
  }
  close(con)
  
  # read data
  dt <- data.table::fread(input = file, skip = skip_lines, header = TRUE, showProgress = showProgress)  
  # fix header: #contig -> contig
  colnames(dt)[1] <- gsub("^#", "", colnames(dt)[1])
  
  # number of fields for container
  n <- -1
  # create container depending on determined result/method type 
  # and populate field
  if (type == "call-pileup") {
    n <- nrow(dt)
    r <- .create_call_pileup(n)
  } else if (type == "rt-arrest") {
    n <- nrow(dt)
    r <- .create_rt_arrest(n)
  } else if (type == "lrt-arrest") {
    # TODO
    r <- .create_lrt_arrest(n)
  } else {
    stop("Unknown type: ", type)
  }
  
  # TODO copy data
  r
}

# helper functions to create data container to hold data
.create_call_pileup <- function(n) {
  data.frame(id = character(n), name = character(n),
             contig = character(n), position = integer(n), strand = character(n),
             condition = integer(n), replicate = integer(n),
             bc_A = integer(n), bc_C  = integer(n), bc_G = integer(n), bc_T = integer(n),
             stat = numeric(n))
}
.create_rt_arrest <- function(n) {
  data.frame(id = character(n), name = character(n), 
             contig = character(n), position = integer(n), strand = character(n),
             condition = integer(n), replicate = integer(n),
             type = character(n), count = integer(n),
             bc_A = integer(n), bc_C  = integer(n), bc_G = integer(n), bc_T = integer(n),
             pvalue = numeric(n))
}
.create_lrt_arrest <- function(n) {
  data.frame(id = character(n), name = character(n), 
             contig = character(n), position = integer(n), strand = character(n),
             condition = integer(n), replicate = integer(n),
             type = character(n), count = integer(n),
             bc_position = integer(n), bc_strand = character(n),
             bc_A = integer(n), bc_C  = integer(n), bc_G = integer(n), bc_T = integer(n),
             pvalue = numeric(n))
}

#' Write a JACUSA list object to a file
#'
#' \code{write_jacusa} Stores a list of sites in a file.
#' 
#' @param jacusa List created by \code{read_jacusa()}.
#' @param file String is the filename to store the list.
#' @param extra Vector of strings that define additional elements from the list that 
#'        will be stored in the file. 
#'
#' @export 
write_jacusa <- function(jacusa, file, extra = NULL) {
  bed6 <- names(jacusa)[names(jacusa) %in% c("contig", "start", "end", "name", "stat", "pvalue", "strand")]
  
  data_fields <- c()
  data_type <- 0

  # add bases fields
  i <- grep("^bases", names(jacusa))
  base_fields <- names(jacusa)[i]
  if (length(base_fields > 0)) {
    data_fields <- c(data_fields, base_fields)
    data_type <- data_type + 1
  }
  
  # add ref2bc fields
  i <- grep("^ref2bc", names(jacusa))
  ref2bc_fields <- names(jacusa)[i]
  if (length(ref2bc_fields > 0)) {
    data_fields <- c(data_fields, ref2bc_fields)
    data_type <- data_type + 1
  }
  
  # add read arrest through fields
  i <- grep("^reads", names(jacusa))
  reads_fields <- names(jacusa)[i]
  if (length(reads_fields > 0)) {
    data_fields <- c(data_fields, reads_fields)
    data_type <- data_type + 1
  }

  # rearrange data fields
  if (data_type == 2) {
    tmp <- vector("character", length(data_fields))
    n <- length(data_fields)
    h <-  n / 2
    tmp[seq(1, n, 2)] <- data_fields[1:h]
    tmp[seq(2, n, 2)] <- data_fields[(h+1):n]
    data_fields <- tmp
  }
  
  info <- names(jacusa)[names(jacusa) %in% c("info", "filter_info", "ref")]
  
  fields <- c(bed6, data_fields, info)
  if (! is.null(extra)) {
    fields <- c(fields, extra)
  }

  jacusa <- jacusa[fields]

  d <- as.data.frame(jacusa, stringsAsFactors = FALSE, check.names = FALSE)
  colnames(d)[1] <- paste0("#", colnames(d)[1])
  utils::write.table(d, file, col.names = TRUE, row.names = FALSE, quote = FALSE, sep = "\t")
}
