#' Read JACUSA2 result file
#'
#' \code{read_result()} Reads data that was generated by JACUSA2 and creates a JACUSA2 list object.
#'
#' @param file String represents the filename of the JACUSA2 output.
#' @param showProgress Boolean indicates if progress should be monitored.
#'
#' @export
read_result <- function(file, showProgress = TRUE, method = "auto") {
  # pre process file
  # parse comments ^(#|##) to determine result/method type and number of conditions
  con <- file(file, "r")
  conditions <- 0
  skip_lines <- 0
  header_names <- NULL
  # skip_lines <- 0
  # possible result/method types: unknown, call-pileup, rt-arrest, lrt-arrest
  type <- .UNKNOWN_METHOD_TYPE
  while (TRUE) {
    line = readLines(con, n = 1)
    # quit reading: nothing to read or first no header line 
    if (length(line) == 0 || length(grep("^#", line)) == 0) {
      break
    }
    # count header lines to ignore
    skip_lines <- skip_lines + 1

    if (length(grep("^#contig", line)) > 0) {
      # try to guess result/method by header line
      type <- .guess_file_type(line)
      # check that the type could be guessed
      if (type == .UNKNOWN_METHOD_TYPE) {
        stop("Result type could not be guessed for file: ", file)
      }
          
      # parse and store header
      # fix header: #contig -> contig
      header_names <- sub("^#", "", line);
      header_names <- unlist(strsplit(header_names, "\t"))
      
      # guess number of conditions  
      conditions <- .guess_conditions(type, header_names)
    }
  }
  # finished pre-processing
  close(con)
  
  # check that the type could be guessed
  if (type == .UNKNOWN_METHOD_TYPE) {
    stop("Result type could not be guessed for file: ", file)
  }
  
  # check that a header could be parsed
  if (is.null(header_names)) {
    stop("No header line for file: ", file)
  }
  
  # check that conditions could be guessed
  if (conditions < 1) {
    stop("Conditions could not be guessed for file: ", file)
  }
  
  # read data
  data <- data.table::fread(file, 
                            skip = skip_lines, 
                            sep = "\t",
                            header = FALSE, 
                            showProgress = showProgress)  
  colnames(data) <- header_names

  # create combined position id from genomic coordinates
  data$id <- paste(data$contig, 
                   data$start, data$end, 
                   data$strand, 
                   sep = ":")
  
  # create container depending on determined result/method type 
  container <- .create_container(type, conditions, data)
  
  container
}

# Create container for type and conditions from data 
.create_container <- function(type, conditions, data) {
  container <- NULL
  if(type == .CALL_PILEUP_METHOD_TYPE) {
    container <- .create_call_pileup(conditions, data)
  } else if (type == .RT_ARREST_METHOD_TYPE) {
    container <- .create_rt_arrest(conditions, data)
  } else if (type == .LRT_ARREST_METHOD_TYPE) {
    container <- .create_lrt_arrest(conditions, data)
  } else {
    stop("Unknown type: ", type)
  }
  container$type <- type

  # add base call
  bc <- apply(container[, paste0("bc_", .BASES)], 1, function(x) { 
    names(x)[x > 0]
  } )
  # add allele count
  container$allele_count <- unlist(lapply(bc, length))
  bc <- unlist(lapply(bc, paste0, collapse = ","))
  container$bc <- gsub("bc_", "", bc)

  # extract data from info field
  #containter <- tidyr::separate_rows(containter, .INFO_COLUMN, sep = ";")                                                                                                                                                      
  #containter <- tidyr::separate(containter, 
  #                       col = .INFO_COLUMN, 
  #                       into = c("key", "value"), 
  #                       sep = "=")                                                                                                                           
  #containter <- tidyr::spread(containter, key, value, convert = TRUE)
  
  container
}

.create_bases <- function(conditions, dt, default_bases = "all") {
  # convert wide to long
  r <- tidyr::gather(dt, sample, bases, dplyr::contains("bases"))
  i <- startsWith(r$sample, "bases")
  if (length(i) > 0) {
    r$sample[i] <- paste0(default_bases, "_", r$sample[i])
  }

  # extract condition and replicate
  r <- tidyr::extract(r, sample, c("base_type", "condition", "replicate"), 
                      regex = paste0("^(.+)_bases([0-9]{", nchar(conditions), "})([0-9]+)"), 
                      remove = TRUE, convert = TRUE)
  # extract base call columns from "," encoded strings
  # convert string: "0,10,2,0" to new columns: bc_A = 0, bc_C = 10, bc_G = 2, bc_T = 0
  r <- tidyr::separate(r, bases, paste0("bc_", c("A", "C", "G", "T")), 
                       sep = ",", remove = TRUE, convert = TRUE)

  # TODO
  if (length(unique(r$base_type)) == 1) {
    r$base_type <- NULL
  }
  
  r
}

# helper functions to create data container to hold data
.create_call_pileup <- function(dt, conditions) {
  r <- .create_bases(dt, conditions)

  r
}

.create_rt_arrest <- function(dt, conditions) {
  r <- .create_bases(dt, conditions)
  # TODO aggregate
  
  r
}

.create_lrt_arrest <- function(dt, conditions) {
  r <- .create_bases(dt, conditions)
  # TODO aggregate
  
  r
}