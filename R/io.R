#' TODO Read JACUSA result file
#'
#' \code{read_jacusa()} Reads data that was generated by JACUSA2.
#'
#' @param file String represents the filename of the JACUSA output.
#' @param ... Additional parameters that will be forwarded to read.table.
#'
#' @export
read_jacusa <- function(file, ...) {
	d <- utils::read.table(file, header = TRUE, stringsAsFactors = FALSE, check.names = FALSE, comment.char = "", ...) 
	colnames(d)[1] <- gsub("^#", "", colnames(d)[1])
	jacusa <- as.list(d)
	jacusa
}

#' Read JACUSA result file
#'
#' \code{read_result()} Reads data that was generated by JACUSA2 and create a special data.frame.
#'
#' @param file String represents the filename of the JACUSA2 output.
#' @param showProgress Boolean indicates if a progress should be monitored.
#'
#' @export
read_result <- function(file, showProgress = TRUE) {
  # TODO
  # fallback when conditions cannot be guessed from header

  # pre process file
  # parse comments ^(#|##) to determine result/method type and number of conditions
  con = file(file, "r")
  conditions <- 0
  header_names <- NULL
  skip_lines <- 0
  # possible result/method types: unknown, call-pileup, rt-arrest, lrt-arrest
  type <- "unknown"
  while (TRUE) {
    line = readLines(con, n = 1)
    # quit reading: nothing to read or first no header line 
    if (length(line) == 0 || length(grep("^#", line)) == 0) {
      break
    }
    # count header lines to ignore
    skip_lines <- skip_lines + 1

    # count condition header lines
    if (length(grep("^## condition", line)) > 0) {
      conditions <- conditions + 1
    }
    # try to guess result/method by header line
    if (type == "unknown" && length(grep("^#contig", line)) > 0) {
      if (length(grep("ref2bc", line)) > 0) { # lrt-arrest
        type <- "lrt-arrest"
      } else if(length(grep("reads", line)) > 0) { # rt-arrest
        type <- "rt-arrest"
      } else if (length(grep("bases", line)) > 0) { # call-pileup
        type <- "call-pileup"
      } else { # ERROR: type could not be guessed
        stop("Result type cannot be guessed from header:\n", line)
      }
      
      # parse and store header
      # fix header: #contig -> contig
      header_names <- sub("^#", "", line);
      header_names <- unlist(strsplit(header_names, "\t"))
    }
  }
  # finished pre-processing
  close(con)
  
  # FIXME
  if (conditions == 0) {
    conditions = 2
  }
  
  # read data
  dt <- data.table::fread(file, skip = skip_lines, header = FALSE, showProgress = showProgress)  
  colnames(dt) <- header_names
  
  # create container "r" depending on determined result/method type 
  r <- NULL
  if (type == "call-pileup") {
    r <- .create_call_pileup(dt, conditions)
  } else if (type == "rt-arrest") {
    r <- .create_rt_arrest(dt, conditions)
  } else if (type == "lrt-arrest") {
    r <- .create_lrt_arrest(dt, conditions)
  } else {
    stop("Unknown type: ", type)
  }
  # create combined position id from genomic coordinates
  r$id <- paste0(r$contig, ":", r$end, ":", r$strand)

  r
}

# helper functions to create data container to hold data
.create_call_pileup <- function(dt, conditions) {
  # convert wide to long (samples start with "bases(condition)(replicate)")
  r <- tidyr::gather(dt, sample, bases, dplyr::starts_with("bases"))
  # extract condition and replicate
  r <- tidyr::extract(r, sample, c("condition", "replicate"), 
               regex = paste0("^bases([0-9]{", nchar(conditions), "})([0-9]+)"), 
               remove = TRUE, convert = TRUE)
  # extract base call columns from "," encoded strings
  # convert string: "0,10,2,0" to new columns: bc_A = 0, bc_C = 10, bc_G = 2, bc_T = 0
  r <- tidyr::separate(r, bases, paste0("bc_", c("A", "C", "G", "T")), 
                sep = ",", remove = TRUE, convert = TRUE)
  r
}
.create_rt_arrest <- function(dt, conditions) {
  r <- .create_call_pileup(dt, conditions)
  # convert wide to long (samples start with "reads(condition)(replicate)")
  tmp_r <- tidyr::gather(dt[, grep("^reads", colnames(dt))], sample, reads, dplyr::starts_with("reads"))
  # not needed; condition and replicate already set
  # extract read arrest and read through columns from "," encoded strings
  # convert string: "0,10" to new columns: read_arrest = 0, read_through = 10
  tmp_r <- tidyr::separate(tmp_r, reads, paste0("read_", c("arrest", "through")), 
                           sep = ",", remove = TRUE, convert = TRUE)
  
  # append tmp_r
  r$read_arrest <- tmp_r$read_arrest
  r$read_through <- tmp_r$read_through
}
.create_lrt_arrest <- function(dt, conditions) {
  # convert wide to long (samples start with "reads(condition)(replicate)")
  tmp_r <- tidyr::gather(dt[, grep("^reads", colnames(dt))], sample, reads, dplyr::starts_with("reads"))
  # not needed; condition and replicate already set
  # extract read arrest and read through columns from "," encoded strings
  # convert string: "0,10" to new columns: read_arrest = 0, read_through = 10
  tmp_r <- tidyr::separate(tmp_r, reads, paste0("read_", c("arrest", "through")), 
                       sep = ",", remove = TRUE, convert = TRUE)
  
  # convert wide to long (samples start with "ref2bc(condition)(replicate)")
  r <- tidyr::gather(dt, sample, ref2bc, dplyr::starts_with("ref2bc"))
  # extract condition and replicate
  r <- tidyr::extract(r, sample, c("condition", "replicate"), 
               regex = paste0("^ref2bc([0-9]{", nchar(conditions), "})([0-9]+)"), 
               remove = TRUE, convert = FALSE)

  # append tmp_r
  r$read_arrest <- tmp_r$read_arrest
  r$read_through <- tmp_r$read_through
  
  # base substitutions per read arrest position
  # expected format: 
  # "*" if no base sub.
  # on base sub.: 100:10,0,0,0 -> at ref. pos. 100 there are 10 A(denosines)
  # base sub. separated by ";"
  base_sub <- strsplit(r$ref2bc, ";")
  base_sub_count <- unlist(lapply(base_sub, length))
  base_sub <- unlist(base_sub)
  i <- base_sub == "*"
  base_sub[i] <- "-1:0,0,0,0"
  # create container to fit base substitutions
  r <- r[rep(seq(1, nrow(r)), base_sub_count), ]
  # store base substitutions in container
  r$ref2bc <- base_sub
  # split 100:10,0,0,0 -> bc_position = 100, bc_A = 10, bc_C = 0, bc_G = 0, bc_T = 0
  r <- tidyr::extract(r, ref2bc,
                into = c("bc_position", paste0("bc_", c("A", "C", "G", "T"))), 
                regex = paste0("([0-9-]+):([0-9]+),([0-9]+),([0-9]+),([0-9]+)"), 
                remove = TRUE, convert = TRUE)
  i <- r$bc_position == -1
  r$bc_position[i] <- NA

  r
}

#' Write a JACUSA list object to a file
#'
#' \code{write_jacusa} Stores a list of sites in a file.
#' 
#' @param jacusa List created by \code{read_jacusa()}.
#' @param file String is the filename to store the list.
#' @param extra Vector of strings that define additional elements from the list that 
#'        will be stored in the file. 
#'
#' @export 
write_jacusa <- function(jacusa, file, extra = NULL) {
  bed6 <- names(jacusa)[names(jacusa) %in% c("contig", "start", "end", "name", "stat", "pvalue", "strand")]
  
  data_fields <- c()
  data_type <- 0

  # add bases fields
  i <- grep("^bases", names(jacusa))
  base_fields <- names(jacusa)[i]
  if (length(base_fields > 0)) {
    data_fields <- c(data_fields, base_fields)
    data_type <- data_type + 1
  }
  
  # add ref2bc fields
  i <- grep("^ref2bc", names(jacusa))
  ref2bc_fields <- names(jacusa)[i]
  if (length(ref2bc_fields > 0)) {
    data_fields <- c(data_fields, ref2bc_fields)
    data_type <- data_type + 1
  }
  
  # add read arrest through fields
  i <- grep("^reads", names(jacusa))
  reads_fields <- names(jacusa)[i]
  if (length(reads_fields > 0)) {
    data_fields <- c(data_fields, reads_fields)
    data_type <- data_type + 1
  }

  # rearrange data fields
  if (data_type == 2) {
    tmp <- vector("character", length(data_fields))
    n <- length(data_fields)
    h <-  n / 2
    tmp[seq(1, n, 2)] <- data_fields[1:h]
    tmp[seq(2, n, 2)] <- data_fields[(h+1):n]
    data_fields <- tmp
  }
  
  info <- names(jacusa)[names(jacusa) %in% c("info", "filter_info", "ref")]
  
  fields <- c(bed6, data_fields, info)
  if (! is.null(extra)) {
    fields <- c(fields, extra)
  }

  jacusa <- jacusa[fields]

  d <- as.data.frame(jacusa, stringsAsFactors = FALSE, check.names = FALSE)
  colnames(d)[1] <- paste0("#", colnames(d)[1])
  utils::write.table(d, file, col.names = TRUE, row.names = FALSE, quote = FALSE, sep = "\t")
}
