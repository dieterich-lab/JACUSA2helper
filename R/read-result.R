#' Reads JACUSA2 result file and creates a result object.
#'
#' \code{read_result()} Reads data that was generated by JACUSA2 and creates a JACUSA2 result object.
#'
#' @param file string that represents the filename of the JACUSA2 output.
#' @param unpack_info boolean indicating if additional data stored in 'info' field should be unpacked.
#' @examples
#' TODO
#' @export
read_result <- function(file, unpack_info = TRUE) {
  # parse comments ^(#|##) to determine result/method type and number of conditions
  con <- file(file, "r")
  cond_rep <- NULL
  skip_lines <- 0
  data_header <- NULL
  jacusa_header <- NULL
  # possible result/method types: check SUPPORTED_METHOD_TYPES
  while (TRUE) {
    line = readLines(con, n = 1)
    # quit reading: nothing to read or first no header line 
    if (length(line) == 0 || length(grep("^#", line)) == 0) {
      break
    }
    # count header lines to ignore
    skip_lines <- skip_lines + 1

    if (length(grep("^##", line)) != 0) { # JACUSA2 header line
      jacusa_header <- c(jacusa_header, trimws(gsub("(^##)", "", line)))
    } else if (length(grep("^#contig", line)) > 0) { # data header line
      # try to guess result/method by header line
      # type will be valid or guess_file_type throws an error
      type <- guess_file_type(line)

      # parse and store header
      # fix header: #contig -> contig
      data_header <- sub("^#", "", line);
      data_header <- unlist(strsplit(data_header, "\t"))

      # guess number of conditions
      cond_rep <- get_condition_replicate(type, data_header)
    }
  }
  # finished pre-processing
  close(con)
  
  # check that a header could be parsed
  if (is.null(data_header)) {
    stop("No data header line for file: ", file)
  }
  
  conditions <- find_conditions(cond_rep)
  cond2rep <- get_cond2rep(cond_rep)
  
  # check that conditions could be guessed
  if (conditions < 1 || length(cond2rep) != conditions) {
    stop("Conditions could not be guessed for file: ", file)
  }

  # read data
  data <- data.table::fread(
    file, 
    skip = skip_lines, 
    sep = "\t",
    header = FALSE, 
    showProgress = TRUE
  )  
  colnames(data) <- data_header

  # create result depending on determined method type 
  result <- create_result(type, cond_rep, data, unpack_info)
  # finally store header information (e.g.: JACUSA2 version) in result
  result <- set_header(result, jacusa_header)

  tibble::as_tibble(result)
}

# Create result for type and conditions from data 
#' @noRd
create_result <- function(type, cond_rep, data, unpack_info) {
  # replace redundant and unnecessary columns with id
  data$id <- 1:nrow(data)
  # add more columns in method specific if-clause
  store_columns <- c(FILTER_INFO_COLUMN, REF_BASE_COLUMN)
  # add more columns in method specific if-clause
  method_column_prefix <- NULL
  
  # container for result
  result <- NULL
  if(type == CALL_PILEUP_METHOD_TYPE) {
    store_columns <- c(BED_COLUMNS, store_columns)
    method_column_prefix <- BASES_COLUMN
  } else if (type %in% c(RT_ARREST_METHOD_TYPE, LRT_ARREST_METHOD_TYPE)) {
    # this methods has pvalues as default score
    store_columns <- c(gsub("score", "pvalue", BED_COLUMNS), store_columns)
    method_column_prefix <- c(ARREST_COLUMN, THROUGH_COLUMN)
    if (type == LRT_ARREST_METHOD_TYPE) {
      store_columns <- c(store_columns, ARREST_POS_COLUMN)
    }
  } else {
    stop("Unknown type: ", type)
  }
  # split data 
  # general purpose, e.g.: coordinates, filter_info, ref_base, etc.
  tmp_data <- dplyr::select(data, c(store_columns, "id"))
  # method specific, e.g.: bases11, arrest_pos, etc.
  data <- dplyr::select(data, -store_columns)
  
  result <- process_fields(
    data, 
    cond_rep, 
    as.vector(outer(method_column_prefix, cond_rep, paste0)), # all combinations of method_columns and cond_red
    unpack_info
  )

  # merge split data
  result <- merge(tmp_data, result, by = "id")

  # add cov etc.
  result <- post_process(type, method_column_prefix, result)  
  # TODO rearrange
  result <- set_method(result, type)
  
  # make factors
  result$condition <- as.factor(result$condition)
  result$replicate <- as.factor(result$replicate)
  
  result
}

#' @noRd
unpack_variables <- function(data) {
  tidyr::separate_rows(data, info, sep = ";") %>%
    tidyr::separate(info, into = c("key", "value"), sep = "=", fill = "right") %>% 
    tidyr::extract(key, c("variable", "sample"), regex = "^(.+[^0-9]{1})([0-9]*)")
}

# FIXME currently limited to 9 conditions - see regex
#' @noRd
spread_variables <- function(data, columns) {
  tidyr::gather(data, "key", "value", columns) %>%
    tidyr::extract(
      key, c("variable", "condition", "replicate"),
      regex = "^(.+[^0-9]{1})([0-9]{1})([0-9]+)", # variable|condition|replicate
      remove = TRUE, convert = TRUE
    ) %>%
    tidyr::spread(variable, value)
}

# helper functions to create data container to hold data
#' @noRd
process_fields <- function(data, cond_rep, method_columns, unpack_info) {
  cond2rep <- get_cond2rep(cond_rep)
  conditions <- length(cond2rep)

  variables <- NULL
  variables_unpacked <- NULL
  if (unpack_info) {
    data <- unpack_variables(data)
    variables_unpacked <- unique(data$variable)
    
    not_empty_variable_i <- ! is.na(data$variable) & data$variable != EMPTY
    if (any(not_empty_variable_i)) {
      sample <- data$sample[not_empty_variable_i]
      data$sample[not_empty_variable_i] <- fill_sample(sample, cond2rep)
      data <- tidyr::separate_rows(data, sample, sep = ",")
    }
    
    data <- tidyr::replace_na(data, list(variable = "", sample = "", value = "")) %>%
      tidyr::unite(key, variable, sample, sep = "")

    variables <- unique(na.omit(data$key))
    variables <- variables[variables != ""]
    
    data <- tidyr::spread(data, key, value, convert = TRUE)
    # remove empty fields
    if ("V1" %in% colnames(data)) {
      data <- dplyr::select(data, -V1) 
    }
  }
  columns <- NULL
  if (! is.null(variables)) {
    columns <- c(method_columns, variables)
  }
  
  # convert wide to long
  data <- spread_variables(data, columns)

  # keep track what variables have been created from file
  if (! is.null(variables_unpacked)) {
    attributes(data)[[UNPACKED]] <- variables_unpacked
  }
  
  data
}

#' @noRd
post_process <- function(type, method_column_prefix, result) {
  for (col in method_column_prefix) {
    bases_str <- fix_empty_bases(result[[col]])
    result[[col]] <- extract_bases(bases_str)
    result <- add_bc_obs(result, col)
    result <- add_cov(result, col)
  }
  
  # methods specific adjustments
  # add new column: bases, etc.  <- arrrest + through etc.
  if (type %in% CALL_PILEUP_METHOD_TYPE) {
    # nohing to be done
  } else if (type %in% c(RT_ARREST_METHOD_TYPE, LRT_ARREST_METHOD_TYPE)) {
    # derived from arrest and through columns
    result[[BASES_COLUMN]] <- result[[ARREST_COLUMN]] + result[[THROUGH_COLUMN]]
    result <- add_bc_obs(result)
    result <- add_cov(result)
    result <- add_arrest_rate(result)
    
    i <- FIX_NUMERIC_COLUMNS %in% names(result)
    if (any(i)) {
      # fix type of some columns
      for (col in FIX_NUMERIC_COLUMNS[i]) {
        result[[col]] <- as.numeric(result[[col]])
      }
    }
  } else {
    stop("Unknown type: ", type)
  }
  
  if (READ_SUB_COLUMN %in% names(result)) {
    print("Let it flow")
    browser()
  }
  
  result
}

#' TODO
#' 
#' TODO
#' 
#' @param src TODO
#' @param dest TODO
#' @return \code{dest} with attributes copied from \code{src}
#' @export
copy_attr <- function(src, dest) {
  if (check_method(src)) {
    dest <- copy_method(src, dest)
    dest <- copy_header(src, dest)
  }

  dest
}

#' @noRd
fill_sample <- function(sample, cond2rep) {
  # collect indices to fix on different criteria
  empty_i <- sample == "" # all conditions and their replicates missing
  missing_rep_i <- nchar(sample) == 1 # all replicates for condition missing
  
  # process indices
  if (any(empty_i)) {
    sample[empty_i] <- paste0(cond2rep, collapse = ",")
  }
  if (any(missing_rep_i)) {
    sample[missing_rep_i] <- cond2rep[sample[missing_rep_i]]
  }

  # fix sample later  
  gsub("_", "", sample)
}

#' @noRd
get_cond2rep <- function(cond_rep) {
  # create named vector that maps from condition to all replicates, e.g.:
  # condition: 1 -> 1_1 (no replicates)
  #            2 -> 2_1,2_2 (one replicate)
  # ASSUMPTION only < 10 conditions
  cond <- substring(cond_rep, 1, 1)
  rep <- substring(cond_rep, 2)
  tapply(paste(cond, rep, sep = "_"), cond, paste0, collapse = ",")
}
