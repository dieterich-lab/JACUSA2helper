#' Reads JACUSA2 result file and creates a result object.
#'
#' \code{read_result()} Reads data that was generated by JACUSA2 and creates a JACUSA2 result object.
#'
#' @param file string that represents the filename of the JACUSA2 output.
#' @param unpack_info boolean indicating if additional data stored in 'info' field should be unpacked.
#' @export
read_result <- function(file, unpack_info = TRUE) {
  file_info <- pre_read(file)
  # check that a header could be parsed
  if (is.null(file_info$data_header)) {
    stop("No data header line for file: ", file)
  }  
  
  condition_info <- process_condition(file_info$type, file_info$data_header)
  # check that conditions could be guessed
  if (condition_info$conditions < 1 || 
      length(condition_info$cond2rep) != condition_info$conditions) {
    stop("Conditions could not be guessed for file: ", file)
  }

  data <- read_data(file, file_info$skip_lines, file_info$data_header)
  # create result depending on determined method type 
  result <- create_result(
    file_info$type, 
    condition_info$cond_rep, 
    data, 
    unpack_info
  )
  
  # finally store header information (e.g.: JACUSA2 version) in result
  result <- set_header(result, file_info$jacusa_header)
  
  result
}

#' @noRd
pre_read <- function(file) {
  # parse comments ^(#|##) to determine result/method type and number of conditions
  con <- file(file, "r")
  type <- UNKNOWN_METHOD_TYPE
  skip_lines <- 0
  data_header <- NULL
  jacusa_header <- c()
  while (TRUE) {
    line = readLines(con, n = 1)
    # quit reading: nothing to read or first no header line 
    if (length(line) == 0 || length(grep("^#", line)) == 0) {
      break
    }
    # count header lines to ignore
    skip_lines <- skip_lines + 1
    
    if (length(grep("^##", line)) != 0) { # JACUSA2 header line
      jacusa_header <- c(jacusa_header, trimws(gsub("(^##)", "", line)))
    } else if (length(grep("^#contig", line)) > 0) { # data header line
      # try to guess result/method by header line
      # type will be valid or guess_file_type throws an error
      type <- guess_file_type(line)
      
      # parse and store header
      # fix header: #contig -> contig
      data_header <- sub("^#", "", line);
      data_header <- unlist(strsplit(data_header, "\t"))
    }
  }
  # finished pre-processing
  close(con)
  
  list(
    type = type,
    skip_lines = skip_lines,
    data_header = data_header,
    jacusa_header = jacusa_header
  )
}

#' @noRd
process_condition <- function(type, data_header) {
  # guess number of conditions
  cond_rep <- get_condition_replicate(
    type, 
    data_header
  )
  
  list(
    cond_rep = cond_rep,
    conditions = find_conditions(cond_rep),
    cond2rep = get_cond2rep(cond_rep)
  )
}

#' @noRd
read_data <- function(file, skip_lines, data_header) {
  data <- data.table::fread(
    file, 
    skip = skip_lines, 
    sep = "\t",
    header = FALSE, 
    showProgress = TRUE
  )  
  colnames(data) <- data_header
  
  data
}

# Create result for type and conditions from data 
#' @noRd
create_result <- function(type, cond_rep, data, unpack_info) {
  # replace redundant and unnecessary columns with id
  data$id <- 1:nrow(data)
  
  columns <- process_columns(type)
  if (META_CONDITION_COLUMN %in% names(data)) {
    columns$store <- c(columns$store, META_CONDITION_COLUMN)
  }

  # split data 
  # general purpose, e.g.: coordinates, filter, ref, [meta] etc.
  tmp_data <- dplyr::select(data, c(columns$store, "id"))
  # method specific, e.g.: bases11, arrest_pos, etc.
  data <- dplyr::select(data, -c(columns$store))
  
  result <- process_fields(
    data, 
    cond_rep, 
    as.vector(outer(columns$method_prefix, cond_rep, paste0)), # all combinations of method_columns and cond_red
    unpack_info
  )

  # merge split data
  result <- merge(tmp_data, result, by = "id") %>% 
    tibble::as_tibble()
  
  # add cov etc.
  result <- post_process(type, columns$method_prefix, result)
  # TODO rearrange
  result <- set_method(result, type)
  
  # make factors
  result[[CONDITION_COLUMN]] <- as.factor(result[[CONDITION_COLUMN]])
  result[[REPLICATE_COLUMN]] <- as.factor(result[[REPLICATE_COLUMN]])
  
  result
}

#' @noRd
process_columns <- function(type) {
  # add more columns in method specific if-clause
  store <- c(FILTER_INFO_COLUMN, REF_BASE_COLUMN)
  # add more columns in method specific if-clause
  method_prefix <- NULL
  
  # container for result
  result <- NULL
  if(type == CALL_PILEUP_METHOD_TYPE) {
    store <- c(BED_COLUMNS, store)
    method_prefix <- BASES_COLUMN
  } else if (type %in% c(RT_ARREST_METHOD_TYPE, LRT_ARREST_METHOD_TYPE)) {
    # this methods has pvalues as default score
    store <- c(gsub("score", "pvalue", BED_COLUMNS), store)
    method_prefix <- c(ARREST_COLUMN, THROUGH_COLUMN)
    if (type == LRT_ARREST_METHOD_TYPE) {
      store <- c(store, ARREST_POS_COLUMN)
    }
  } else {
    stop("Unknown type: ", type)
  }
  
  list(
    store = store,
    method_prefix = method_prefix
  )
}

#' @noRd
unpack_variables <- function(data) {
  tidyr::separate_rows(data, info, sep = ";") %>%
    tidyr::separate(info, into = c("key", "value"), sep = "=", fill = "right") %>% 
    tidyr::extract(key, c("variable", "sample"), regex = "^(.+[^0-9]{1})([0-9]*)")
}

# FIXME currently limited to 9 conditions - see regex
#' @noRd
spread_variables <- function(data, columns) {
  tidyr::gather(data, "key", "value", columns) %>%
    tidyr::extract(
      key, c("variable", CONDITION_COLUMN, REPLICATE_COLUMN),
      regex = "^(.+[^0-9]{1})([0-9]{1})([0-9]+)", # variable|condition|replicate
      remove = TRUE, convert = TRUE
    ) %>%
    tidyr::spread(variable, value)
}

# helper functions to create data container to hold data
#' @noRd
process_fields <- function(data, cond_rep, method_columns, unpack_info) {
  cond2rep <- get_cond2rep(cond_rep)
  conditions <- length(cond2rep)

  variables <- NULL
  variables_unpacked <- NULL
  if (unpack_info) {
    data <- unpack_variables(data)
    variables_unpacked <- unique(data$variable)
    
    not_empty_variable_i <- ! is.na(data$variable) & data$variable != EMPTY
    if (any(not_empty_variable_i)) {
      sample <- data$sample[not_empty_variable_i]
      data$sample[not_empty_variable_i] <- fill_sample(sample, cond2rep)
      data <- tidyr::separate_rows(data, sample, sep = ",")
    }
    
    data <- tidyr::replace_na(data, list(variable = "", sample = "", value = "")) %>%
      tidyr::unite(key, variable, sample, sep = "")

    variables <- unique(na.omit(data$key))
    variables <- variables[variables != ""]
    
    data <- tidyr::spread(data, key, value, convert = TRUE)
    # remove empty fields
    if ("V1" %in% colnames(data)) {
      data <- dplyr::select(data, -V1) 
    }
  }
  columns <- NULL
  if (! is.null(variables)) {
    columns <- c(method_columns, variables)
  }
  
  # convert wide to long
  data <- spread_variables(data, columns)

  # keep track what variables have been created from file
  if (! is.null(variables_unpacked)) {
    attributes(data)[[UNPACKED]] <- variables_unpacked
  }
  
  data
}

#' @noRd
post_process <- function(type, method_column_prefix, result) {
  for (col in method_column_prefix) {
    bases_str <- fix_empty_bases(result[[col]])
    bases <- extract_bases(bases_str)
    result[[col]] <- bases
    result <- add_bc(result, col)
    result <- add_cov(result, col)
  }
  
  # methods specific adjustments
  # add new column: bases, etc.  <- arrrest + through etc.
  if (type %in% CALL_PILEUP_METHOD_TYPE) {
    # nohing to be done
  } else if (type %in% c(RT_ARREST_METHOD_TYPE, LRT_ARREST_METHOD_TYPE)) {
    # derived from arrest and through columns
    result[[BASES_COLUMN]] <- result[[ARREST_COLUMN]] + result[[THROUGH_COLUMN]]
    result <- add_bc(result)
    result <- add_cov(result)
    result <- add_arrest_rate(result)
    
    i <- FIX_NUMERIC_COLUMNS %in% names(result)
    if (any(i)) {
      # fix type of some columns
      for (col in FIX_NUMERIC_COLUMNS[i]) {
        result[[col]] <- as.numeric(result[[col]])
      }
    }
  } else {
    stop("Unknown type: ", type)
  }
  
  if (READ_SUB_COLUMN %in% names(result)) {
    print("Let it flow")
    browser()
  }
  
  result
}

#' TODO
#' 
#' TODO
#' 
#' @param src TODO
#' @param dest TODO
#' @return \code{dest} with attributes copied from \code{src}
#' @export
copy_attr <- function(src, dest) {
  if (check_method(src)) {
    dest <- copy_method(src, dest)
    dest <- copy_header(src, dest)
  }

  dest
}

#' @noRd
fill_sample <- function(sample, cond2rep) {
  # collect indices to fix on different criteria
  empty_i <- sample == "" # all conditions and their replicates missing
  missing_rep_i <- nchar(sample) == 1 # all replicates for condition missing
  
  # process indices
  if (any(empty_i)) {
    sample[empty_i] <- paste0(cond2rep, collapse = ",")
  }
  if (any(missing_rep_i)) {
    sample[missing_rep_i] <- cond2rep[sample[missing_rep_i]]
  }

  # fix sample later  
  gsub("_", "", sample)
}

#' @noRd
get_cond2rep <- function(cond_rep) {
  # create named vector that maps from condition to all replicates, e.g.:
  # condition: 1 -> 1_1 (no replicates)
  #            2 -> 2_1,2_2 (one replicate)
  # ASSUMPTION only < 10 conditions
  cond <- substring(cond_rep, 1, 1)
  rep <- substring(cond_rep, 2)
  tapply(paste(cond, rep, sep = "_"), cond, paste0, collapse = ",")
}
