#' Reads JACUSA2 result file and creates a result object.
#'
#' \code{read_result()} Reads data that was generated by JACUSA2 and creates a JACUSA2 result object.
#'
#' @param file string that represents the filename of the JACUSA2 output.
#'
#' @export
read_result <- function(file) {
  # parse comments ^(#|##) to determine result/method type and number of conditions
  con <- file(file, "r")
  conditions <- 0
  skip_lines <- 0
  data_header <- NULL
  jacusa_header <- NULL
  # possible result/method types: check SUPPORTED_METHOD_TYPES
  while (TRUE) {
    line = readLines(con, n = 1)
    # quit reading: nothing to read or first no header line 
    if (length(line) == 0 || length(grep("^#", line)) == 0) {
      break
    }
    # count header lines to ignore
    skip_lines <- skip_lines + 1

    if (length(grep("^##", line)) != 0) { # JACUSA2 header line
      jacusa_header <- c(jacusa_header, trimws(gsub("(^##)", "", line)))
    } else if (length(grep("^#contig", line)) > 0) { # data header line
      # try to guess result/method by header line
      # type will be valid or guess_file_type throws an error
      type <- guess_file_type(line)

      # parse and store header
      # fix header: #contig -> contig
      data_header <- sub("^#", "", line);
      data_header <- unlist(strsplit(data_header, "\t"))

      # guess number of conditions
      conditions <- guess_conditions(type, data_header)
    }
  }
  # finished pre-processing
  close(con)

  # check that a header could be parsed
  if (is.null(data_header)) {
    stop("No data header line for file: ", file)
  }
  
  # check that conditions could be guessed
  if (conditions < 1) {
    stop("Conditions could not be guessed for file: ", file)
  }
  
  # read data
  data <- data.table::fread(
    file, 
    skip = skip_lines, 
    sep = "\t",
    header = FALSE, 
    showProgress = TRUE
  )  
  colnames(data) <- data_header

  # create result depending on determined method type 
  result <- create_result(type, conditions, data)
  # finally store header information (e.g.: JACUSA2 version) in result
  result <- set_jacusa_header(result, jacusa_header)

  result
}

# Create result for type and conditions from data 
create_result <- function(type, conditions, data) {
  info <- dplyr::select(data, contig, start, end, strand, info)
  result <- NULL
  if(type == CALL_PILEUP_METHOD_TYPE) {
    result <- create_bases(data, conditions, BASES_COLUMN)
    result[["primary"]] <- TRUE
  } else if (type == RT_ARREST_METHOD_TYPE) {
    result <- create_bases(data, conditions, c(ARREST_COLUMN, THROUGH_COLUMN))
    result[["primary"]] <- TRUE
  } else if (type == LRT_ARREST_METHOD_TYPE) {
    result <- create_bases(data, conditions, c(ARREST_COLUMN, THROUGH_COLUMN))
    i <- result$arrest_pos == result$end & 
      result$base_type %in% c("total", c(ARREST_COLUMN, THROUGH_COLUMN))
    result[["primary"]] <- FALSE
    result[["primary"]][i] <- TRUE
  } else {
    stop("Unknown type: ", type)
  }
  result <- set_jacusa_method(result, type)

  # add base call
  result$bc <- apply(result[, paste0("bc_", BASES)], 1, function(x) { 
    paste0(BASES[x > 0], collapse = "")
  })

  # only parse deletions, if there are any
  # TODO parse info field
  #if (any(grep("^deletion", info$info))) {
  #  result <- merge(
  #    result, 
  #    process_deletion(conditions, info), 
  #    by = c("contig", "start", "end", "strand", "condition", "replicate"),
  #    all.x = TRUE
  #  )
  #}

  # make factors
  result$condition <- as.factor(result$condition)
  result$replicate <- as.factor(result$replicate)
  # 
  result <- add_coverage(result)
  # TODO do user like this?
  # result_names <- names(result)
  # i <- c(
  #   "contig", "end", "strand", 
  #   "primary", "base_type", 
  #   "bc", paste0("bc_", BASES), 
  #   "score"
  # ) %in% result_names
  # result <- dplyr::select(!!!rlang::syms(c(names[i], names[! i])))

  dplyr::as_tibble(result)
}

# helper function to extract deletion info(s)
# TODO check
process_deletion <- function(conditions, info) {
  df <- info %>% 
    tidyr::separate_rows(info, INFO_COLUMN, sep = ";") %>% 
    tidyr::separate(
      col = !! INFO_COLUMN, 
      into = c("key", "value"), 
      sep = "=", fill = "right") %>% 
    dplyr::filter(key != EMPTY) %>%
    tidyr::spread(key, value) %>% 
    tidyr::gather(
      key = "deletion_sample", 
      value = "deletion_counts", 
      dplyr::matches("^deletions")) %>%
    tidyr::extract(
      deletion_sample, 
      c("condition", "replicate"), 
      regex = paste0("^deletions([0-9]{", nchar(conditions), "})([0-9]+)"), 
      remove = TRUE, convert = TRUE) %>%
    tidyr::separate(deletion_counts, paste0("deletion_", c("reads", "coverage")), 
                    sep = ",", remove = TRUE, convert = TRUE)
  
  df$deletion_pvalue <- as.numeric(df$deletion_pvalue)
  df$deletion_score <- as.numeric(df$deletion_score)
  
  df
}

# helper functions to create data container to hold data
create_bases <- function(df, conditions, column) {
  # convert wide to long
  r <- tidyr::gather(
    df, 
    sample, bases, 
    lapply(column, dplyr::starts_with) %>% 
      unlist()
  )

  # FIXME currently limit to 9 conditions
  regex = paste0(
    "^(", paste0(column, collapse = "|"), ")",
    "([1-9]{", nchar(conditions), "})",
    "([0-9]+)"
  )

  # extract condition and replicate
  r <- tidyr::extract(
    r, 
    sample, c("base_type", "condition", "replicate"),
    regex = regex,
    remove = TRUE, convert = TRUE
  )

  # replcace empty(=*) base call vectors with 0,0,0,0
  i <- r$bases == EMPTY
  r$bases[i] <- paste0(rep(0, length(BASES)), collapse = ",")

  # extract base call columns from "," encoded strings
  # convert string: "0,10,2,0" to new columns: bc_A = 0, bc_C = 10, bc_G = 2, bc_T = 0
  r <- tidyr::separate(
    r, bases, paste0("bc_", BASES),
    sep = ",", 
    remove = TRUE, convert = TRUE
  )

  # TODO base stratification vs. rt-arrest, lrt-arrest
  # add helper specific column
  # aggregate arrest and through reads
  if (length(unique(r$base_type)) == 1) {
    r$base_type <- "total"
  } else {
    # FIXME
    r <- group_by_site(r, ARREST_POS_COLUMN, condition, replicate) %>%
      dplyr::mutate(
        base_type = "total", 
        bc_A = sum(bc_A), 
        bc_C = sum(bc_C), 
        bc_G = sum(bc_G), 
        bc_T = sum(bc_T)
      ) %>%
      # TODO test if this is needed dplyr::distinct() %>% 
      dplyr::ungroup() %>%
      rbind(r)
  }

  r
}

#' Reads multiple related JACUSA2 results.
#' 
#' Read multiple related - same JACUSA2 method type - files and combines them
#' in one result object. This allows to combine multiple related JACUSA2 results
#' that differ in some meta condition.
#' 
#' @param files vector of JACUSA2 result files.
#' @param meta_conditions vector of strings providing details about each file.
#' @return combined JACUSA2 result object.
#'
#' @export
read_results <- function(files, meta_conditions) {
  stopifnot(length(files) == length(meta_conditions))

  types <- SUPPORTED_METHOD_TYPES
  headers <- list()
  # read all files  
  l <- mapply(function(file, meta_condition) {
    # use default read function and
    result <- read_result(file)
    # add corresponding meta conditition description
    result$meta_condition <- meta_condition

    # this makes sure that all files have the same JACUSA2 type
    type <- get_jacusa_method(result)
    if (! type %in% types) {
      stop("All files must have the same type. File: ", file, " has type: ", type)
    }
    # ugly but conveniernt "global" variable manipulation
    types <<- type
    headers[[meta_condition]] <- get_jacusa_header(result)

    return(result)
  }, files, meta_conditions, USE.NAMES = FALSE, SIMPLIFY = FALSE)

  # combine read files
  results <- dplyr::bind_rows(l)
  results$meta_condition <- as.factor(results$meta_condition)

  # types should be ONE element of SUPPORTED_METHOD_TYPES
  results <- set_jacusa_method(results, types)
  results <- set_jacusa_header(results, headers)

  results
}

#' @noRd
add_coverage <- function(result) {
  result[["coverage"]] <- rowSums(result[, paste0("bc_", BASES)])

  result
}

#' @noRd
get_jacusa_method <- function(result) {
  attributes(result)[[METHOD_TYPE]]
}

#' @noRd
set_jacusa_method <- function(result, type) {
  attributes(result)[[METHOD_TYPE]] <- type

  result
}

#' @noRd
check_jacusa_method <- function(result, types = SUPPORTED_METHOD_TYPES) {
  all(get_jacusa_method(result) %in% types)
}

require_jacusa_method <- function(result, types = SUPPORTED_METHOD_TYPES) {
  if (! check_jacusa_method(result, types)) {
    stop(
      "result must be of type: ", paste0(types, sep = ","), ".\n",
      "Current type: ", get_jacusa_method(result)
    )
  }
}

#' @noRd
copy_jacusa_method <- function(src, dest) {
  if (! check_jacusa_method(src)) {
    stop("Unknown JACUSA method type for src: ", src)
  }
  type <- get_jacusa_method(src)
  dest <- set_jacusa_method(dest, type)

  dest
}

#' @noRd
get_jacusa_header <- function(result) {
  attributes(result)[[HEADER]]
}

#' @noRd
set_jacusa_header <- function(result, header) {
  attributes(result)[[HEADER]] <- header

  result
}

#' @noRd
copy_jacusa_header <- function(src, dest) {
  header <- get_jacusa_header(src)
  dest <- set_jacusa_header(dest, header)

  dest
}

#' @noRd
copy_jacusa_attributes <- function(src, dest) {
  if (check_jacusa_method(src)) {
    dest <- copy_jacusa_method(src, dest)
    dest <- copy_jacusa_header(src, dest)
  }

  dest
}
